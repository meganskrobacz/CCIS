The key to my AI – and, generally-speaking, to my entire program – was the ability to determine what moves are legal based on the color of the player. To do this, my design focused heavily on the “Records” class, whose sole purpose was to track moves and use that data to determine whether a proposed move is legal or not. For tracking moves, I kept a global variable nested list, MASTER_LIST. This stored all the moves (coordinates and player color) that have been played in the game, giving my program a source of truth to compare to for a whole host of other functions. Each time a move was played, it was appended to MASTER_LIST and, if a piece was flipped due to a play, that pre-flipped piece was removed from MASTER_LIST and the piece was added. As such, my class was able to keep an up-to-date record of all current plays in the game.

With this in mind, each time an instance of Records was generated – either by the player or the computer – my functions would do the following to determine a list of valid moves:

1) Based on the size of the board, a nested list of possible coordinates would be generated 
2) That list was then compared to the MASTER_LIST, and any coordinates that were already occupied were removed. This left a list of coordinates that were unoccupied.
3) That list of unoccupied coordinates was then iterated through in the following fashion:

a. The first method would determine the coordinates of the squares surrounding the coordinate in question
b. A second method would figure out which of those squares were occupied, and remove those that weren’t
c. A third method would then look at those occupied squares and only keep the coordinates occupied by a piece of a different color. Since a valid move is only one where the player is surrounding a line of opposite color pieces, this is the first step to identifying coordinates that would be valid plays.
d. If by this time it’s determined that the coordinate is indeed surrounded in some form or fashion by at least one piece of the opposite color, another method determine what “direction” that piece is in relation to the proposed coordinate. For example, if the opponent piece is directly above the proposed move, the direction would be [0, 1] because the x-coordinate would stay the same, but the y coordinate would increase by one.
e. The nested lists from c) and d) are then passed into another method, which is designed to determine the outcome if that play was implemented. The method iterates through each entry in c) and, using its corresponding direction, keeps going down that line until one of the following base cases is hit:
i. The board runs out – thus it’s not a valid move
ii. It runs into a blank space – thus it’s not a valid move
iii. It runs into a piece of the player color – thus, it is a valid move.
f. The method in e) will return a nested list of the pieces that will flip given the proposed move. An additional helper function “cleans” the list to remove blank entries from directions that wouldn’t do anything, thus leaving a list of only pieces that would flip if the move is played.
g. Finally, if the length of that “to flip” list is greater than zero – in other words, if there are indeed pieces that would flip – the pieces themselves are added to a general “would flip” list, and the play itself is added to a general “valid move” list. It’s crucial to note that in both of these lists, the valid move and its corresponding pieces that would flip will have the same index, thus allowing them to be linked in that fashion.

Once a list of valid moves is generated, the program can compare the proposed move of a human player to that list – thus determining if it’s a valid play right away. Additionally, if it’s the computer’s turn, the AI can automatically pick the “best” move by iterating through the “to flip” list and selecting the one with the longest list of pieces that would flip. Once it figures out what is the longest, it identifies its index of that entry, calls the corresponding coordinate in the “valid moves” list, and plays that coordinate. For easier reference, I have this “best move” identified in __init__  when an instance is created.

As such, I very much attempted to make the AI as smart as it can be – it, by design, automatically plays the move that will score the highest points per round. I’m quite pleased by the design, and I think it does a pretty great job of creating a challenging opponent; it beat the human player over 60% of the time. I think that to improve the design, I would need to account for what happens if, after the “best” white move is played, the human player then plays the “best” black move off the results. In other words, if the “best” white move opens up a valid human play that would significantly increase the human score, I need to take that into account when determining whether that is indeed the “best” move for the AI to play.
